
## shared_recursive_timed_mutex
shared_timed_mute 기반으로 구현을 시도하니, 
공유 락이 지속적으로 시도가 될 경우 독점 락 진입이 불가능해지는 치명적인 문제가 발생
=> 락 우선도 구현 필요(독점락 > 공유락)
우선도에 따라 락을 걸면, 독점 락에 의해 공유락의 점유 효율성이 크게 떨어지는 문제 발생.
=> 내부적으로 점유 대기 타임을 측정해, 독점락의 지연을 감지하고 공유락의 진입을 막고 최우선적으로 점유권 할당.

TODO:
우선도 인플레이션 방지책
우선도에 대한 표준화된 규칙이 없으므로, debug 모드일 경우 내부적으로 평균이 0

atomic_flag: 5 ~ 60us
스핀락: 0.5 ~ 2us
std::this_thread::yield();은 미미하게 느려짐 => 큰 의미 없음.

아래 처럼 접근하면 데드락 발생 확인
```
lock_test
0 lock_shared
1 lock_shared
0 lock
1 lock_shared
1 unlock_shared
1 lock

```
원인은 두 스레드가 공유락을 가진 채, 둘 다 락을 획득하려고 하면 데드락이 발생,
구현의 문제가 아닌 논리적인 문제임을 확인.


므로 이 상황이 발생하는 경우 예외 던지도록 개선.


